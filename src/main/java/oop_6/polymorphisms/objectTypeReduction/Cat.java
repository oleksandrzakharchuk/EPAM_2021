package oop_6.polymorphisms.objectTypeReduction;
//В контексте полиморфизма бывает необходимость получить доступ ко всем методам экземпляра класса-наследника при оперировании им через ссылку на класс-родителя. Такое поведение называется приведением типов объектов. Приведение возможно:
//к типу своего класса к одному из его подклассов, суперклассов, или интерфейсов.
//[](![img_5.png](img_5.png))
//Например:
//Objectobj="abracadabra";
//Stringstr= (String)obj;
//При попытке выполнить приведение объекта к типу класса, который не входит в иерархию наследования исходного объекта, будет выброшено исключение ClassCastException

//пример, в котором описан суперкласс Cat с методом move(). Также описаны два его подкласса BritishCat и PersianCat, которые переопределяют этот метод. В классе Main создадим ссылку cat типа Cat и инициализируем ее объектом класса BritishCat. Если затем ссылку cat привести к типу BritishCat, то все пройдет корректно, т.к. объект тот же, но теперь мы смотрим на него не просто как на кошку, а именно кошку британской породы. Однако если ссылку cat привести к типу PersianCat, то получим ошибку во время исполнения – ClassCastException. Это происходит потому, что типы BritishCat и PersianCat находятся в разных ветках наследования.
//Во избежание такой ошибки выполняют проверку на корректность приведения с помощью оператора instanceof. Этот оператор имеет следующий синтаксис: instanceof

public class Cat {
    public void move() {
        System.out.println("Cat move");
    }
}

//public class BritishCat extends Cat {

    //Оператор instanceof возвращает true, если значение RelationalExpression не нулевое (null) и может быть приведено к ReferenceType, не выбрасывая ClassCastException (то есть если объект является объектом данного класса, или одного из его подклассов, или одного из его суперклассов). В противном случае результат — false.

    //Результат применения этого оператора по отношению к ссылке null — всегда ложь, потому что null нельзя причислить к какому-либо типу.

     //   if(сat  instanceof PersianCat)

  //  {//Например, для выше указанного примера перед приведением нужно было проверить такую возможность:
      //  System.out.println("Persian cat!");
     //   PersianCat сat3 = (PersianCat) сat;
   // } else

  //  {
 //       System.out.println("Not Persian cat!");
 //   }


//}

//Что дает полиморфизм?
//
//Поскольку суперклассы и подклассы образуют иерархию по степени увеличения специализации, это позволяет подклассам определять собственное поведение при сохранении единообразия интерфейса с суперклассом. Это возможно благодаря общей форме методов.
//Тип объектной ссылки определяет разновидность объектов, на которые через нее можно ссылаться.
//Через ссылку на суперкласс можно вызывать только унаследованные методы суперкласса, то есть собственные методы подкласса нельзя вызвать через объектную ссылку на суперкласс.

//Повторное использование
//Если существует код, который работает с супертипом, то его возможно использовать и для работы с объектами подтипов. Это позволяет подменять реализации объектов. На этом основано тестирование.

//Надежность
//Компилятор выполняет проверки, связанные с использованием типов данных. Это защищает от появления ошибок исполнения, связанных с некорректным применением различных операций над разными типами данных, входящих в некоторое семейство.

//Более модульная структура
//При проектировании архитектуры программы программист может выделять компоненты, которые впоследствии может заменять на другие. При этом код будет оставаться работоспособным.

//Гибкость в расширении
//Возможность добавлять новые типы данных и применять их в существующем рабочем коде.

//https://docs.oracle.com/javase/tutorial/java/IandI/polymorphism.html

//Полиморфизм — это предоставление единого интерфейса для сущностей (объектов) разных типов или использование одного обозначения для представления разных типов.
//Наиболее распространенное использование полиморфизма в ООП: применение ссылки на суперкласс для обращения к объекту подкласса.
//Статическое связывание происходит во время компиляции, а динамическое — во время исполнения программы. Статический полиморфизм выполняется быстрее, так как нет динамических накладных расходов, но требуется дополнительная поддержка от компилятора. Динамический полиморфизм более гибок, но выполняется медленнее – так как динамически связанная библиотека может работать с объектами, не зная их полного типа.
//Приведение типов объектов – получение доступа ко всем методам экземпляра класса-наследника при оперировании им через ссылку на класс-родителя. Проверку на корректность такого приведения с помощью оператора instanceof.