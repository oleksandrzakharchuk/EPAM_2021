package oop_6.polymorphisms.methodsOverload;

public class Overload {

        public void test(String s) {//различные сигнатуры
            s = "abcd";
            System.out.println("test(String)");
        }
        public void test(double dd) {//различные сигнатуры
            System.out.println("test(double)");
        }
        public double test(int i, double f) {//различные сигнатуры
            System.out.println("test(int, double)");
            return i * f;
        }
    }
//Если в одном классе присутствуют два метода с одинаковыми именами, то списки их параметров должны отличаться. Такие методы считаются перегруженными (overloading).
//
//Java различает методы по их сигнатуре – это имя метода, число и типы его параметров. Это позволяет в пределах одного класса определить два или более методов, которые совместно используют одно и то же имя, но имеют разный список параметров.
//
//
//Это происходит из-за необходимости однотипных действий с данными разного типа и количества:
//
//тип возвращаемого значения не учитывается при разрешении перегруженных методов
//статические методы могут перегружаться нестатическими, и наоборот (ограничений нет).

//При обращении вызывается доступный метод — происходит разрешение перегрузки. Это происходит во время компиляции. Метод, который будет исполняться, компилятор подбирает по сигнатуре метода, типу передаваемых аргументов и включает в себя следующие этапы:
// Этап 1 Выяснение имени метода,который будет вызываться, и какой класс/интерфейс требуется проверить для этого имени метода.
//Этап 2 Поиск типа и методов-кандидатов для применения, то есть тех методов, которые могут быть корректно вызваны по заданным аргументам.

//Этап 3 Выбор из кандидатов метода, который фактически выполнится во время исполнения. Выбор из кандидатов метода для выполнения тоже происходит в несколько шагов и учитывает сначала количество, затем типы и порядок следования типов данных. Процесс состоит из следующих шагов:
//Точное совпадение количества и типов аргументов и параметров метода.
//Если точного совпадения нет, то для аргументов используется приведения типов:
//для примитивных типов – расширяющее
//для объектных/ссылочных – к ближайшему супертипу.
//Если приведение не сработало, то используется механизм автоупаковки/автораспаковки – между примитивными типами и соответствующими им классами обертками.
//Если на предшествующих шагах не был найден метод, то проверяются методы переменной арности – если такие есть среди кандидатов.