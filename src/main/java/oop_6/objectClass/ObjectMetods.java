package oop_6.objectClass;
//В корне иерархии всех классов находится класс java.lang.Object, который является наиболее общим из всех классов. java.lang.Object является прародителем (суперклассом) всех объектов. Это начальный класс, из которого произведены все остальные классы. Методы, определенные в Object, очень важны, так как они появляются в каждом экземпляре каждого класса по всей Java.
//
// Каждый класс имеет класс Object в качестве суперкласса (неявно).
//Все объекты, включая массивы, наследуют методы этого класса.
//Объектами не являются лишь простые типы: числа, символы и логические значения.
//
// какие методы включает класс Object:
//
// equals(Object obj)  Метод, который возвращает результат сравнения двух объектов      hashCode()          Метод, который возвращает уникальный идентификатор объекта()     toString()          Метод, который возвращает представление объекта в виде строки.
// clone()             Метод, который возвращает созданную копию объекта.
// getClass()          Возвращает объект типа Class (описание класса объекта).
// wait()              Переводит поток в состояние ожидания.
// notify()            Возобновляет (уведомляет) один из потоков, вызвавших метод wait() на этом же объекте.
// notifyAll()         Возобновляет (уведомляет) все потоки, вызвывших метод wait() на этом же объекте.
// finalize() Выполняет завершающую работу перед уничтожением объекта сборщиком мусора.


import java.io.InterruptedIOException;

public class ObjectMetods {
    //public final Class getClass() - возвращает объект класса класс. Метод final никогда не переопределяться. Для создания обектов какогото класса первоначально создаеться обект класса класс - для любого класса. И это  обект класса класс всегда единственный. Например чтобы определить принадлежность к какому то конкретному типу достаточно  извлечь из ссылок на обект--вызвать метод  getClass() и просто сравнить. Если значения идентичны то значит эти обекты относяться именно к одному и тому же типу.

   // public int hashCode() и  // public boolean equals(Object obj)  - образуют пару - должны переопределяться одновременно. Переопределяються для классов которые несут какую - либо информацию

   // protected Object clone()throws CloneNotSupportedException - выполняет клонирование обекта. protected - означает что метод будет вызван из нутри подкласса. Позволяет создать побитовую копию обекта.

    //public String toString() - строковое представление обекта. То что програмист хочет сообщить об обекте то и помещаеться в этот метод. Возвращает строковое представление объекта. У класса Object этот метод возвращает строку, которая состоит из:
     //имени класса
    //символа "@"
    //беззнакового шестнадцатеричного представления хэш-кода объекта.
    //getClass().getName() + "@" + Integer.toHexString(hashCode())
    //Метод toString() должен возвращать краткое, но информативное представление объекта.
    //Рекомендуется переопределять этот метод во всех пользовательских классах. Большинство методов toString() возвращают строку, состоящую из имени класса, за которым указываются значения его полей в квадратных скобках.


    //public final void notify() и //public final void notifyAll()- используються при роботе с многопоточностью и используються только в синхронайзед блоках или методах исоответственно только рассматриваються в этом разделе.


    //public  final void wait(long timeout)throws InterruptedException
    //public  final void wait(long timeout, int nanos)throws InterruptedException
    //public  final void wait()throws InterruptedException

    //protected void finalize()throws Throwable - depricated - не рекомендован к использованию. Не очень хароший аналог деструктора. Предназначен для очистки ресурсов. Но выполняет эту роль не очень качественно.  Вместо того чтобы очистить ресурсы и сделать программу быстрее. На самом деле использование метода finalize() может привести к замедлению работы программы. Работа непосредственно связанна с работой garbeg kollector.

// equals(Object obj)
// Метод, который возвращает результат сравнения двух объектов Метод equals() класса Object проверяет, эквивалентны ли два объекта. В реализации этого метода используется оператор сравнения на равенство (==).
//
//Обратите внимание, что для примитивных типов данных оператор сравнения на равенство дает правильный результат, однако для объектов – нет, так как метод equals() проверяет, равны ли ссылки на объекты, то есть являются ли сравниваемые объекты одним и тем же объектом. В качестве проверки эти действия вполне оправданы: любой объект будет эквивалентен сам себе.
// public boolean equals(Object obj) {
//    return (this == obj);
//}Для некоторых классов большего и не требуется. Однако в ряде случаев эквивалентными должны считаться объекты одного типа, имеющие одинаковые состояния.
//
// При переопределении метода equals()-->

// обязательно должны выполняться соглашения, предусмотренные спецификацией языка Java:

// Рефлексивность --Если взять любое значение ссылки х, не равное null, то результатом вызова x.equals(х) должно быть true.

// Симметричность --Если взять любые значения ссылок х и у, не равные null, то результат вызова x.equals(у) должен быть таким же, как и вызов y.equals(х).
//
// Транзитивность --Если взять любые значения ссылок х, у, и z, не равные null, и результаты вызова x.equals(у) и y.equals(z) равны true, то и результат вызова x.equals(z) также должен быть true.
//
// Согласованность--Если взять любые значения ссылок х и у, не равные null, то при многократном вызове x.equals(у) возвращаемое значение (true или false) всегда должно быть одинаковым. Исключением будет ситуация, если нет информации об изменении используемых в сравнении объектов.
//
// Сравнение с null--Если взять любое значение ссылки х, не равное null, то результатом вызова x.equals(null) должно быть false.
    //Итак, метод equals() класса Object проверяет, эквивалентны ли два объекта.

    //Oсновными рекомендациями по созданию данного метода.
    //
    //Предположим, что явный параметр метода equals() называется obj. Впоследствии obj будет приведен к другому типу и записан в переменную other.

    //Шаг 1 - Проверка идентичности ссылок:
    //Необходимо проверить, идентичны ли ссылки this и obj. Данное выражение используется для оптимизации проверки: гораздо быстрее проверить идентичность ссылок, чем сравнивать поля объектов.
    //
    //if (this == obj) return true;

    //Шаг - 2 Проверка нулевой ссылки
    //Необходимо выяснить, является ли ссылка obj нулевой (null). Если да, то следует вернуть значение false. Эту проверку нужно сделать обязательно.
    //
    //if (obj == null) return false;

    //Шаг - 3 Сравнение классов
    //Необходимо сравнить классы this и obj. Если семантика проверки может измениться в подклассе, то нужно использовать метод getClass().
    //
    //if (this.getClass() != obj.getClass()) return false;

    //Шаг - 4 Использование instanceof
    //Если принцип проверки остается справедливым для всех подклассов, то следует использовать операцию instanceof.
    //
    //if (!(obj instanceof NameClass)) return false;

    //Шаг - 5 Преобразование в переменную
    //Необходимо преобразовать объект obj в переменную требуемого класса.
    //
    //NameClass other = (NameClass) obj;

    // Шаг - 6 Сравнение полей
    //Важно! Если в подклассе переопределяется метод equals(), в него надо включить вызов super.equals(other).

    //equals method
    // --> it is reflexive: for any non-null referens value x, x.equals(x) should return true(объект всегда должен быть равен себе)
    //--> it is symmetric: fr any non-null reference values x and y, x.equals(y) should return true if and only if y.equals(x) returns true.(если Х=У то У=Х)
    //-->it is transitive: for any non-null reference values x, y, and z, if x.equals(y) returns true and y.equals(z) return true, then x.equals(z) should return true.(если х еквивалентен У а У еквывалентен z то Х еквивалентен Z )
    //-->it is consistent: for any non-null reference values x and y, multiple invocations of x.equals(y) consistently return true or consistently return false, provided no information used in equals comparisons on the objects is modified.(если реализованы три правила то нужно быть жостаточно проффесиональным програмистом чтобы нарушить это-- если две ссылки например, два обекта истинны, выдают истинную еквивалннтность при множественном вызове то оно не должно меняться на false. Два неизменяющиеся во времени обекты- на них вызываеться метод  equals, если впервый раз появилось true то это true не должно измениться вообще (тоже касаеться false)   )
    //-->For any non-null reference value x, x.equals(null) should return false.(по сравнению с null любой не null обект должен быть false)


    //hashCode method
    //-->whenever it ivoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application.(хеш-код это некоторый числовой еквивалент вычисляемый на основе значений полей класса, полейобекта. И соответственно если два обекта еквивалентны то хеш код должен быть одинаковым)
    //-->If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result.( если же два обекта различны то хеш-код может быть различным.  Т.е обект может быт нееквивалентен но иквелс может возвращать одинаковые значения )
    //-->It is not required that if two objects are unequal according to the equals(java.lang.Object) method, then calling the hashCode method on each of the two objects must produce distinct integer results. However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hash tables.

    //Методы equals() и hashCode() должны быть совместимы: если х.equals(у) возвращает значение true, то результаты выполнения x.hashCode() и y.hashCode() также должны совпадать.








//public class Point {
//    ...
//    public boolean equals(Point other) {
//        return this.x == other.x && this.y == other.y;
//    }
//При выполнении данного кода возникнет проблема. Однако начиная с Java SE 5.0 появилась возможность застраховаться от возникновения подобной ошибки. Для этого нужно указать, что разрабатываемый метод призван заместить соответствующий метод суперкласса. Для этой цели используется дескриптор @Override:
//@Override
//public boolean equals(Object obj)
//Если при этом вы случайно определите новый метод, компилятор вернет сообщение об ошибке. Предположим, что в классе Point присутствует приведенная ниже строка кода:
    //@Override
    //public boolean equals(Point obj)
//Поскольку данный метод не переопределяет никакого метода, определенного в суперклассе Object, то будет обнаружена ошибка.


    //Метод hashCode()
    // возвращает значение хэш-кода объекта. Данный метод определен в классе Object. Поэтому каждый объект имеет хэш-код, определяемый по умолчанию.

    //Хэш-функция
    //Хэш-функция – это любая функция, которая может быть использована для отображения

    //Значение Хэш
    //Значение Хэш – это результат выполнения хэш-функции. Также используются названия: хэш-значение, хэш-код, хэш-сумма или просто хэш, а также хЕш вместо хЭш.
    //
    // Хэш объекта в Java – это целое число, генерируемое на основе применения хэш-функции на конкретном объекте. Хэш-код можно рассматривать как некоторый шифр: если х и у – разные объекты, то с высокой степенью вероятности должны различаться результаты вызовов х.hashCode() и у.hashCode().
    //
    //Метод hashCode() необходим для корректной работы с коллекциями, например HashMap.
    //В классе Object этот метод вычисляет хэш-код посредством преобразования адреса размещения объекта в памяти в целое число.
    //Метод hashCode() следует переопределять всегда, когда переопределен метод equals(Object).

    //При переопределении метода hashCode() нужно обязательно соблюдать три соглашения по переопределению хэш-кода, а именно:
    //
    //Если во время выполнения Java-приложения метод вычисления хэш-кода будет вызван на одном и том же объекте несколько раз, то он должен возвращать одно и то же значение, если только объект не изменялся.
    //В случае, когда два объекта равны (результат вызова equals(Object) – true), то при вызове метода вычисления хэш-кода для каждого из этих двух объектов он должен возвращать один и тот же результат.
    //В случае, когда два объекта не равны (результат вызова equals(Object) – false), то при вызове метода вычисления хэш-кода для каждого из этих двух объектов, желательно, чтобы он возвращал разные результаты.
    //Метод hashCode() должен возвращать целое число (которое может быть отрицательным) – уникальный идентификатор, зависящий в большинстве случаев только от значения свойств объектов. Для того чтобы обеспечить уникальность хэш-кодов для разных объектов, достаточно объединить хэш-коды полей экземпляра.







}
