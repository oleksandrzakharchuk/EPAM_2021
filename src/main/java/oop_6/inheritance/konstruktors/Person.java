package oop_6.inheritance.konstruktors;
//конструкторы не наследуются но при наследовании цепочка вызова конструкторов должна следовать от самого главного суперкласса  и самый главный суперкласс--> Object
// если клас написан без наследования, то по умолчанию компилятор добавит ему эти два слова extends Object наследования от Object.При создании обекта класса Person  слово  super(); указыает на то что первым будет вызван конструктор класа  Object а потом конструктор класса Person().

public class Person extends Object {
    private int id;
    private String name = "";
    public Person(){
        super();
    }
    public Person(int id){
        // по умолчанию компилятор эту строчку вставит сюда и всюду подставит. Перед этой строкой нельзя ставить никакую другую - сразу возникнет ошибка компиляции потому что строка может потенциально привести к ветвлению вызовов - т.е к отсутствию выбора. Всегда должен стоят super(); и стоять один. Перескачить через конструктор супер класса если есть цепочка наследования а,б, с. -С- обратиться на прямую к конструктору класса -а- невозможно. super.super - не проходит.

        super();
        this.id=id;
    }
    public Person(String name){
        this.name=name;
    }
    public Person(int id, String name){
        this.id=id;
        this.name=name;
    }
}
//Класс не может наследоваться от самого себя. В конструкторе класса нельзя совместно использовать вызовы super() и this(), поскольку такой вызов должен быть всегда первым оператором конструктора. Компилятор не помешает переопределить статические методы в подклассах, однако при их вызове будет использоваться механизм раннего связывания. Аннотацию @Override к статическим методам применять нельзя. Статические методы можно перегружать в подклассах. Доступность таких методов зависит от типа ссылки и атрибута доступа.

//Наследование позволяет упорядочить классы в иерархии, которая представляет отношения типа "is-a" (является типом/ разновидностью).

