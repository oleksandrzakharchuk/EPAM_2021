package class_5.classConstructor.Subject;

import java.util.Objects;

public class ExSubject {// у класса минимум один конструктор, а может быт сколько угодно
    private long subjectId;
    private String name;
    //конструктор имеет точно такоеже имя как и
    // класс, по имени вызыветься только с пом. опеатора new. По другому его вызвать впринцыпе невозможно по имени. нет возвращаемого значения. Добавление возвращаемого значения сразу превращает конструктор в метод. Получим предупреждение что метод с большой буквы  - код конвеншин плюс предупр что в класе есть метод с именем класса. Тогда конструктор окажеться в списке методов.


    public ExSubject() {// присутствие двух конструкторов - прегрузка конструкторов
    }

     public ExSubject(long subjectId, String name) {// protected - вызов этого конструктора доступен из-под класса в другом пакете и в этом же пакете так-же,
        // private - конструктор доступен из любого метода класса, для этого предварительно должен быть создан объект. А если метод статический то можна предоставлять доступ к объекту (шаблон синглтон занимаеться такими действиями).
        // или ничего - по умолчанию т.е объект этого класса с пом. этого конструктора я смогу создать только в этом пакете, вне пакета этот конструктор недоступен
        //никакие другие ключевые слова перед конструктором стоять не могут! abstract - конструктор не может быть абстрактным. это говорит о том что метод не обявлен в этом классе а будет реализован в подклассе- т.е переопределен- но конструкторы не переопределяються. а соотв абстр констр быть не может.
        // конструкторы только могут быть перегружены в  своем классе и вызваны из под класса

        // final - конструктор не может быть финальный- т.к конструкторы не наследуються. файнел запрещает наследование. конструктор и так не наследуеться.
        // static - вообще абсурд. статический метод вызываеться без обекта, обект класса не нужен вообще, а задача конструктора создавать этот объект. статика не имеет права иметь ссылку this.
        //synchronized-метод синхронизирован- блокируеться обект на котором вызываеться этот метод от других синхронизированных методов этого же обекта. Если будет создано два конструктора то они будут блокировать создание своего собственного обекта.- абсурд

        // присутствие двух конструкторов - прегрузка конструкторов
        super();
       // super1(); ошибка компиляции
        this.subjectId = subjectId;
        // super2(); ошибка компиляции
        this.name = name;
    }

    // public ExSubject() {//конструктор по умолчанию для класса ExSubject. Если область видимости класса не public то и область видимости конструктора по умолчанию не public. Конструктор по умолчанию предоставляеться  только в том случае если конструктор в классе не определен вовсе. Если попытаться определить какой то конструктор то конструктор по умолчанию не будет предоставляться.        Конструктор по умолчанию это конструктор без параметров.

      //  super();
   // }

    public long getSubjectId() { return subjectId;}

    public void setSubjectId(long subjectId) {this.subjectId = subjectId;}

    public String getName() {return name;}

    public void setName(String name) {this.name = name;}

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        ExSubject exSubject = (ExSubject) o;

        return subjectId == exSubject.subjectId && Objects.equals(name, exSubject.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(subjectId, name);
    }
}
